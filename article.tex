\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[ruled,vlined,linesnumbered,algochapter]{algorithm2e}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{float}
\usepackage{placeins}

\SetKwInput{Input}{Input}
\SetKwInput{Output}{Output}
\SetKwInput{Data}{Data}
\SetKwComment{Comment}{// }{}

\title{Haplotype Phasing Algorithms: Complete Decomposition}
\author{Phasing Program Documentation}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}
This document provides a complete algorithmic description of the haplotype phasing program, decomposed into multiple interconnected algorithms. Each algorithm references others to show the complete workflow and data flow.

\section{Main Program Flow}

\begin{algorithm}[H]
\caption{Main Program Execution}
\label{alg:main}
\Input{Command-line arguments: argc, argv}
\Output{Phased haplotypes written to output files}
\BlankLine
Execute Algorithm \ref{alg:parse_args} (Parse Command-Line Arguments)\;
Execute Algorithm \ref{alg:validate_params} (Validate Parameters)\;
Execute Algorithm \ref{alg:initialize} (Initialize Data Structures)\;
Execute Algorithm \ref{alg:read_optional} (Read Optional Input Files)\;
Execute Algorithm \ref{alg:read_genomes} (Read Genome Data Files)\;
Execute Algorithm \ref{alg:process_individuals} (Process All Individuals)\;
\Return{0 (success)}
\end{algorithm}

\begin{algorithm}[H]
\caption{Parse Command-Line Arguments}
\label{alg:parse_args}
\Input{argc, argv}
\Output{Parsed parameters: NbIndiv, PathInput, PathOutput, PathParentInfo, PathListIndiv, inputFormat, outputFormat}
\BlankLine
Initialize all parameters to defaults\;
\ForEach{argument in argv}{
    \eIf{argument is "-NbIndiv"}{
        Read next argument as NbIndiv\;
    }{
        \eIf{argument is "-PathInput"}{
            Read next argument as PathInput\;
        }{
            \eIf{argument is "-PathOutput"}{
                Read next argument as PathOutput\;
            }{
                \eIf{argument is "-PathParentInfo"}{
                    Read next argument as PathParentInfo\;
                }{
                    \eIf{argument is "-ListIndiv"}{
                        Read next argument as PathListIndiv\;
                    }{
                        \eIf{argument is "-InputFormat"}{
                            Read next argument and set inputFormat\;
                        }{
                            \eIf{argument is "-OutputFormat"}{
                                Read next argument and set outputFormat\;
                            }
                        }
                    }
                }
            }
        }
    }
}
\Return{Parsed parameters}
\end{algorithm}

\begin{algorithm}[H]
\caption{Validate Parameters}
\label{alg:validate_params}
\Input{NbIndiv, NBINDIVMAX}
\Output{Validation result}
\BlankLine
\If{NbIndiv == 0}{
    Print error: "Number of individuals is zero"\;
    Exit with error\;
}
\If{NbIndiv > NBINDIVMAX}{
    Print error: "Number of individuals exceeds maximum"\;
    Exit with error\;
}
\Return{Valid}
\end{algorithm}

\begin{algorithm}[H]
\caption{Initialize Data Structures}
\label{alg:initialize}
\Input{None}
\Output{Initialized arrays and data structures}
\BlankLine
Set nbsnpperchr[0..22] to predefined values\;
Initialize chrdivider[25][1..22][0] with default windows\;
Initialize random number generator with seed 0\;
Initialize result matrix to zero\;
Initialize distrigametic and distrigametickeep arrays\;
\Return{Initialized structures}
\end{algorithm}

\section{File Input/Output}

\begin{algorithm}[H]
\caption{Read Optional Input Files}
\label{alg:read_optional}
\Input{PathParentInfo, PathListIndiv}
\Output{Loaded parent information and individual list}
\BlankLine
\If{PathParentInfo is provided}{
    Execute Algorithm \ref{alg:read_parents} (Read Parent Information)\;
}
\If{PathListIndiv is provided}{
    Execute Algorithm \ref{alg:read_list} (Read Individual List)\;
}
\Else{
    Set default: process first 10 individuals\;
}
\Return{Loaded data}
\end{algorithm}

\begin{algorithm}[H]
\caption{Read Parent Information}
\label{alg:read_parents}
\Input{PathParentInfo filename}
\Output{parentinfo array, nbparentinfo}
\BlankLine
Open file PathParentInfo\;
Initialize nbparentinfo = 0\;
\While{not end of file}{
    Read line: Individual\_ID Parent1\_ID Parent2\_ID\;
    Store in parentinfo array\;
    Increment nbparentinfo\;
}
Close file\;
\Return{parentinfo, nbparentinfo}
\end{algorithm}

\begin{algorithm}[H]
\caption{Read Individual List}
\label{alg:read_list}
\Input{PathListIndiv filename}
\Output{listIndivToProcess array, nbIndivToProcess, useListIndiv flag}
\BlankLine
Open file PathListIndiv\;
Initialize nbIndivToProcess = 0\;
\While{not end of file}{
    Read individual ID\;
    Validate ID is in range [0, NbIndiv)\;
    Add to listIndivToProcess\;
    Increment nbIndivToProcess\;
}
Set useListIndiv = true\;
Close file\;
\Return{list, count, flag}
\end{algorithm}

\begin{algorithm}[H]
\caption{Read Genome Data Files}
\label{alg:read_genomes}
\Input{PathInput, inputFormat, NbIndiv}
\Output{genomes array, nbsnpperchrinfile array}
\BlankLine
Allocate memory for genomes[1..22]\;
\eIf{inputFormat == HAP}{
    \ForEach{chromosome from 1 to 22}{
        Execute Algorithm \ref{alg:read_hap} (Read HAP File) for chromosome\;
    }
}{
    \ForEach{chromosome from 1 to 22}{
        Execute Algorithm \ref{alg:read_ped} (Read PED File) for chromosome\;
    }
}
\Return{genomes, nbsnpperchrinfile}
\end{algorithm}

\begin{algorithm}[H]
\caption{Read HAP Format File}
\label{alg:read_hap}
\Input{PathInput, chromosome number, NbIndiv}
\Output{Genome data in compressed format, nbsnpperchrinfile[chr]}
\BlankLine
Open file: PathInput + chromosome + ".hap"\;
Initialize SNP counter = 0\;
\While{not end of file}{
    Read line\;
    Skip first 5 columns (metadata)\;
    \ForEach{individual from 0 to NbIndiv-1}{
        Read allele1 and allele2\;
        Encode: geno = (allele1 << 1) | allele2\;
        Store in compressed format (2 bits per genotype)\;
    }
    Increment SNP counter\;
}
Set nbsnpperchrinfile[chr] = SNP counter\;
Close file\;
\Return{genome data, SNP count}
\end{algorithm}

\begin{algorithm}[H]
\caption{Read PED Format File}
\label{alg:read_ped}
\Input{PathInput, chromosome number, maxIndiv}
\Output{Genome data in compressed format, nbsnpperchrinfile[chr], NbIndiv}
\BlankLine
Open file: PathInput + chromosome + ".ped"\;
Read first data line to determine number of SNPs\;
Initialize individual counter = 0\;
\While{not end of file}{
    Read 6 metadata columns\;
    \ForEach{SNP}{
        Read allele1 and allele2\;
        Encode: geno = (allele1 << 1) | allele2\;
        Store in compressed format\;
    }
    Increment individual counter\;
}
Set nbsnpperchrinfile[chr] = number of SNPs\;
Set NbIndiv = individual counter\;
Close file\;
\Return{genome data, SNP count, individual count}
\end{algorithm}

\begin{algorithm}[H]
\caption{Write Output Files}
\label{alg:write_output}
\Input{PathOutput, outputFormat, genomes, nbsnpperchrinfile, NbIndiv}
\Output{PED or HAP format files}
\BlankLine
\ForEach{chromosome from 1 to 22}{
    \eIf{outputFormat == PED}{
        Execute Algorithm \ref{alg:write_ped} (Write PED File) for chromosome\;
    }{
        Execute Algorithm \ref{alg:write_hap} (Write HAP File) for chromosome\;
    }
}
\Return{Written files}
\end{algorithm}

\begin{algorithm}[H]
\caption{Write PED Format File}
\label{alg:write_ped}
\Input{PathOutput, chromosome, genomes, nbsnpperchrinfile, NbIndiv}
\Output{PED format file}
\BlankLine
Open file: PathOutput + chromosome + ".ped"\;
\ForEach{individual from 0 to NbIndiv-1}{
    Write Family\_ID, Individual\_ID, Father\_ID, Mother\_ID, Sex, Phenotype\;
    \ForEach{SNP from 0 to nbsnpperchrinfile[chr]-1}{
        Decode genotype from compressed format\;
        Extract allele1 and allele2\;
        Write allele1 and allele2\;
    }
    Write newline\;
}
Close file\;
\Return{Success}
\end{algorithm}

\section{Relationship Detection}

\begin{algorithm}[H]
\caption{Find Relatives and Calculate PI-HAT}
\label{alg:findrelative}
\Input{ID, genomes, NbIndiv, nbsnpperchr, nbsnpperchrinfile}
\Output{pihatagainstall array, bestpihatagainstallID array, MAF array}
\BlankLine
Initialize pihatagainstall to zero\;
Execute Algorithm \ref{alg:calculate_maf} (Calculate Minor Allele Frequencies)\;
Execute Algorithm \ref{alg:calculate_pihat} (Calculate PI-HAT Scores)\;
Execute Algorithm \ref{alg:normalize_pihat} (Normalize PI-HAT Values)\;
\Return{PI-HAT scores and related individuals}
\end{algorithm}

\begin{algorithm}[H]
\caption{Calculate Minor Allele Frequencies}
\label{alg:calculate_maf}
\Input{genomes, NbIndiv, nbsnpperchr, nbsnpperchrinfile}
\Output{MAF array}
\BlankLine
\ForEach{chromosome from 1 to 22}{
    \ForEach{SNP in chromosome}{
        Initialize alternate allele count = 0\;
        \ForEach{individual from 0 to NbIndiv-1}{
            Extract genotype at SNP\;
            Count alternate alleles (bits set to 1)\;
            Add to count\;
        }
        Store MAF[snp][chr] = count\;
    }
}
\Return{MAF array}
\end{algorithm}

\begin{algorithm}[H]
\caption{Calculate PI-HAT Scores}
\label{alg:calculate_pihat}
\Input{ID, genomes, MAF, NbIndiv, nbsnpperchr, nbsnpperchrinfile}
\Output{pihatagainstall array}
\BlankLine
\ForEach{chromosome from 1 to 22}{
    \ForEach{SNP in chromosome}{
        Calculate maffloat from MAF[snp][chr]\;
        Extract target individual's genotype\;
        Calculate contribution factors based on MAF\;
        \ForEach{other individual from 0 to NbIndiv-1}{
            Extract other individual's genotype\;
            Calculate PI-HAT contribution\;
            Accumulate to pihatagainstall[other]\;
        }
    }
}
\Return{pihatagainstall array}
\end{algorithm}

\begin{algorithm}[H]
\caption{Normalize PI-HAT Values}
\label{alg:normalize_pihat}
\Input{pihatagainstall array, nbsnpperchrinfile, NbIndiv}
\Output{Normalized pihatagainstall array}
\BlankLine
Calculate total\_snps = sum of nbsnpperchrinfile[1..22]\;
\ForEach{individual from 0 to NbIndiv-1}{
    \If{total\_snps > 0}{
        pihatagainstall[individual] = pihatagainstall[individual] / (2.0 * total\_snps)\;
    }
    \Else{
        pihatagainstall[individual] = 0.0\;
    }
}
\Return{Normalized PI-HAT values}
\end{algorithm}

\section{Individual Processing}

\begin{algorithm}[H]
\caption{Process All Individuals}
\label{alg:process_individuals}
\Input{listIndivToProcess, nbIndivToProcess, PathParentInfo, PathOutput}
\Output{Phased haplotypes for all individuals}
\BlankLine
\ForEach{individual index from 0 to nbIndivToProcess-1}{
    indiv = listIndivToProcess[index]\;
    Execute Algorithm \ref{alg:process_one} (Process One Individual) for indiv\;
}
\Return{Processed individuals}
\end{algorithm}

\begin{algorithm}[H]
\caption{Process One Individual}
\label{alg:process_one}
\Input{indiv, PathParentInfo, PathOutput}
\Output{Phased haplotypes for individual}
\BlankLine
Execute Algorithm \ref{alg:findrelative} (Find Relatives) for indiv\;
Execute Algorithm \ref{alg:get_parents} (Get Parent Information) for indiv\;
\eIf{parents are known and valid}{
    Execute Algorithm \ref{alg:phasing_with_parents} (Phasing With Parents) for indiv\;
}{
    Execute Algorithm \ref{alg:phasing_without_parents} (Phasing Without Parents) for indiv\;
}
Execute Algorithm \ref{alg:write_output} (Write Output Files)\;
\Return{Phased haplotypes}
\end{algorithm}

\begin{algorithm}[H]
\caption{Get Parent Information}
\label{alg:get_parents}
\Input{indiv, parentinfo array, nbparentinfo}
\Output{parent1, parent2}
\BlankLine
\If{PathParentInfo was provided}{
    Search parentinfo array for indiv\;
    \If{found}{
        Return parent1 and parent2 from array\;
    }
    \Else{
        Return parent1 = -1, parent2 = -1\;
    }
}
\Else{
    Return parent1 = -1, parent2 = -1\;
}
\end{algorithm}

\section{Phasing Algorithms}

\begin{algorithm}[H]
\caption{Phasing Without Parent Information}
\label{alg:phasing_without_parents}
\Input{ID, genomes, pihatagainstall, MAF, nbsnpperchr, nbsnpperchrinfile}
\Output{Phased haplotypes in genomes array}
\BlankLine
Extract individual's genotype data\;
Execute Algorithm \ref{alg:configure_windows} (Configure Chromosome Windows)\;
Initialize generation counter = 0\;
\While{generation < MAXGEN}{
    Execute Algorithm \ref{alg:calculate_phase_errors} (Calculate Phase Error Probabilities)\;
    Execute Algorithm \ref{alg:calculate_correlations} (Calculate Window Correlations)\;
    Execute Algorithm \ref{alg:merge_windows} (Merge Highly Correlated Windows)\;
    Execute Algorithm \ref{alg:assign_phases} (Assign Phases to Windows)\;
    Evaluate fitness of current phasing\;
    \If{fitness improved}{
        Update best phasing\;
    }
    \If{no improvement for several generations}{
        Break loop\;
    }
    Increment generation\;
}
Apply best phasing to genomes array\;
\Return{Phased haplotypes}
\end{algorithm}

\begin{algorithm}[H]
\caption{Phasing With Parent Information}
\label{alg:phasing_with_parents}
\Input{ID, parent1, parent2, genomes, pihatagainstall, MAF, nbsnpperchr, nbsnpperchrinfile}
\Output{Phased haplotypes in genomes array}
\BlankLine
Extract individual's genotype data\;
Extract parent1's genotype data\;
Extract parent2's genotype data\;
Execute Algorithm \ref{alg:configure_windows} (Configure Chromosome Windows)\;
Initialize generation counter = 0\;
\While{generation < MAXGEN}{
    Execute Algorithm \ref{alg:calculate_phase_errors_parents} (Calculate Phase Errors With Parents)\;
    Execute Algorithm \ref{alg:calculate_correlations} (Calculate Window Correlations)\;
    Execute Algorithm \ref{alg:merge_windows} (Merge Highly Correlated Windows)\;
    Execute Algorithm \ref{alg:assign_phases_parents} (Assign Phases With Parent Constraints)\;
    Evaluate fitness of current phasing\;
    \If{fitness improved}{
        Update best phasing\;
    }
    \If{no improvement for several generations}{
        Break loop\;
    }
    Increment generation\;
}
Apply best phasing to genomes array\;
\Return{Phased haplotypes}
\end{algorithm}

\section{Window Management}

\begin{algorithm}[H]
\caption{Configure Chromosome Windows}
\label{alg:configure_windows}
\Input{nbsnpperchrinfile, nbsnpperchr}
\Output{chrdivider array, nbchrdivider array}
\BlankLine
\ForEach{chromosome from 1 to 22}{
    \eIf{nbsnpperchrinfile[chr] == nbsnpperchr[chr]}{
        Use predefined fixed windows for chromosome\;
    }{
        Execute Algorithm \ref{alg:create_3000_windows} (Create 3000-SNP Windows) for chromosome\;
    }
    Update maximum number of windows\;
}
\Return{Window configuration}
\end{algorithm}

\begin{algorithm}[H]
\caption{Create 3000-SNP Windows}
\label{alg:create_3000_windows}
\Input{chromosome, nbsnpperchrinfile[chr], window\_size = 3000}
\Output{Window boundaries in chrdivider array}
\BlankLine
Calculate num\_windows = ceil(nbsnpperchrinfile[chr] / window\_size)\;
Ensure 1 <= num\_windows <= 20\;
\ForEach{window from 0 to num\_windows-1}{
    start\_pos = window * window\_size\;
    end\_pos = min((window + 1) * window\_size, nbsnpperchrinfile[chr])\;
    chrdivider[25][chr][window].start = start\_pos\;
    chrdivider[25][chr][window].end = end\_pos\;
}
nbchrdivider[25][chr] = num\_windows\;
\Return{Window boundaries}
\end{algorithm}

\section{Phase Calculation}

\begin{algorithm}[H]
\caption{Calculate Phase Error Probabilities}
\label{alg:calculate_phase_errors}
\Input{ID, relative ID, chromosome, window, MAF, genomes}
\Output{Phase error probabilities for four configurations}
\BlankLine
Initialize probability arrays\;
\ForEach{SNP in window}{
    Calculate MAF for SNP\;
    Extract individual's genotype\;
    Extract relative's genotype\;
    Calculate contribution factors based on MAF\;
    \ForEach{phase configuration (00, 01, 10, 11)}{
        Calculate probability contribution\;
        Accumulate to probability array\;
    }
}
Normalize probabilities\;
\Return{Phase error probabilities}
\end{algorithm}

\begin{algorithm}[H]
\caption{Calculate Phase Errors With Parents}
\label{alg:calculate_phase_errors_parents}
\Input{ID, parent1, parent2, chromosome, window, MAF, genomes}
\Output{Phase error probabilities considering Mendelian inheritance}
\BlankLine
Initialize probability arrays\;
\ForEach{SNP in window}{
    Calculate MAF for SNP\;
    Extract individual's genotype\;
    Extract parent1's genotype\;
    Extract parent2's genotype\;
    Apply Mendelian inheritance rules\;
    Calculate contribution factors\;
    \ForEach{phase configuration}{
        Calculate probability considering parent constraints\;
        Accumulate to probability array\;
    }
}
Normalize probabilities\;
\Return{Phase error probabilities}
\end{algorithm}

\begin{algorithm}[H]
\caption{Calculate Window Correlations}
\label{alg:calculate_correlations}
\Input{Two chromosome windows, phase error probabilities, pihatagainstall}
\Output{Correlation coefficient between windows}
\BlankLine
Initialize sum variables\;
\ForEach{individual with PI-HAT below threshold}{
    Extract phase error probabilities for window 1\;
    Extract phase error probabilities for window 2\;
    Calculate product of probabilities\;
    Accumulate to sum variables\;
}
Calculate correlation coefficient using Pearson's formula\;
\Return{Correlation coefficient}
\end{algorithm}

\begin{algorithm}[H]
\caption{Merge Highly Correlated Windows}
\label{alg:merge_windows}
\Input{Correlation matrix between all windows, correlation threshold}
\Output{Merged window groups}
\BlankLine
Initialize window groups\;
\Repeat{no more pairs to merge}{
    Find pair of windows with highest absolute correlation\;
    \If{correlation exceeds threshold}{
        Merge windows into same group\;
        Update correlation matrix\;
    }
}
\Return{Merged window groups}
\end{algorithm}

\begin{algorithm}[H]
\caption{Assign Phases to Windows}
\label{alg:assign_phases}
\Input{Merged window groups, phase error probabilities}
\Output{Phase assignments for each window}
\BlankLine
\ForEach{window group}{
    Determine phase based on group structure\;
    \ForEach{window in group}{
        Assign phase value\;
        \If{phase requires flipping}{
            Flip alleles in genome data\;
        }
    }
}
\Return{Phase assignments}
\end{algorithm}

\begin{algorithm}[H]
\caption{Assign Phases With Parent Constraints}
\label{alg:assign_phases_parents}
\Input{Merged window groups, phase error probabilities, parent genotypes}
\Output{Phase assignments respecting Mendelian inheritance}
\BlankLine
\ForEach{window group}{
    Determine phase based on group structure and parent constraints\;
    Validate phase assignments against Mendelian rules\;
    \ForEach{window in group}{
        Assign phase value\;
        \If{phase requires flipping}{
            Flip alleles in genome data\;
        }
    }
}
\Return{Phase assignments}
\end{algorithm}

\section{Algorithm Dependencies}

Figure \ref{fig:dependencies} shows the dependency graph of all algorithms.

\begin{figure}[H]
\centering
\begin{verbatim}
Main Program (alg:main)
  ├── Parse Args (alg:parse_args)
  ├── Validate Params (alg:validate_params)
  ├── Initialize (alg:initialize)
  ├── Read Optional (alg:read_optional)
  │   ├── Read Parents (alg:read_parents)
  │   └── Read List (alg:read_list)
  ├── Read Genomes (alg:read_genomes)
  │   ├── Read HAP (alg:read_hap)
  │   └── Read PED (alg:read_ped)
  └── Process Individuals (alg:process_individuals)
      └── Process One (alg:process_one)
          ├── Find Relatives (alg:findrelative)
          │   ├── Calculate MAF (alg:calculate_maf)
          │   ├── Calculate PI-HAT (alg:calculate_pihat)
          │   └── Normalize PI-HAT (alg:normalize_pihat)
          ├── Get Parents (alg:get_parents)
          ├── Phasing Without Parents (alg:phasing_without_parents)
          │   ├── Configure Windows (alg:configure_windows)
          │   │   └── Create 3000 Windows (alg:create_3000_windows)
          │   ├── Calculate Phase Errors (alg:calculate_phase_errors)
          │   ├── Calculate Correlations (alg:calculate_correlations)
          │   ├── Merge Windows (alg:merge_windows)
          │   └── Assign Phases (alg:assign_phases)
          └── Phasing With Parents (alg:phasing_with_parents)
              ├── Configure Windows (alg:configure_windows)
              ├── Calculate Phase Errors Parents (alg:calculate_phase_errors_parents)
              ├── Calculate Correlations (alg:calculate_correlations)
              ├── Merge Windows (alg:merge_windows)
              └── Assign Phases Parents (alg:assign_phases_parents)
      └── Write Output (alg:write_output)
          └── Write PED (alg:write_ped)
\end{verbatim}
\caption{Algorithm Dependency Graph}
\label{fig:dependencies}
\end{figure}

\section{Summary}

This document provides a complete decomposition of the haplotype phasing program into 30+ interconnected algorithms. Each algorithm is self-contained but references others to show the complete workflow. The algorithms are organized into logical groups:

\begin{itemize}
    \item \textbf{Main Program Flow}: Orchestration and control
    \item \textbf{File I/O}: Reading and writing HAP and PED format files
    \item \textbf{Relationship Detection}: Finding relatives and calculating PI-HAT
    \item \textbf{Individual Processing}: Processing each individual through the phasing pipeline
    \item \textbf{Phasing Algorithms}: Core phasing logic with and without parents
    \item \textbf{Window Management}: Creating and configuring chromosome windows
    \item \textbf{Phase Calculation}: Computing phase error probabilities and correlations
\end{itemize}

All algorithms use cross-references (Algorithm \ref{...}) to show their relationships and dependencies, making it easy to understand the complete program flow.

\end{document}

